import { NextFunction, Request, Response } from "express";

import { ApiError } from "../errors";
import { UserValidator } from "../validators";

//Так как очень важно что бы в controller попадали уже валидные данные мы создаем отдельную логику вызова метода валидации в данном файле.
//Методы из этого class UserMiddleware вызываються через его экземпляр внутри router после маршрута (/) и перед методом Controllera данного маршрута.
//Перед тем как любой запрос попадает в controller он заходит в middleware и если здесь проходит проверку на валидацию то далее  в controller попадают уже валидные данные.

class UserMiddleware {
  public isCreateValid(req: Request, res: Response, next: NextFunction) {
    //В методе isCreateValid принимает три аргумента req, res а также next который позволяет при его вызове (если валидация пройдена)
    //перейти с middleware на уровень контролера. **router.post("/", userMiddleware.isCreateValid, userController.create);**
    try {
      const { error, value } = UserValidator.create.validate(req.body);
      if (error) {
        throw new ApiError(error.message, 400);
      }
      //Если при валидации данные не пройдут валидацию то в поле error будет возвращаена ошибка и мы создаем экземпляр ApiError и
      //(это будет объект с конструктором) передаем  в него ошибку(сообщение) и номер статус кода. Выходи из выполнения данной функции

      req.res.locals = value;
      // request это просто большой объект внутри котрого есть много разной информации.Поэтому что бы при условии прохождении валидации
      //передать валидные данный далее мы просто передаем их в объект req, в нем было созданно специальное поле в которое можно записать какую то информацию
      //и в другом месте ее достать. При этом информацию в этом поле можно не типизировать. (req.users=value -> при данной записи пришлось бы вводить ее типизацию.)
      //В данное поле мы передаем валидные данные после этого вызваем метод next()  и эти данный через поле res.locals достаем в Controlere.

      next();
      //Если в next  мы не чего не передаем а просто вызваем  next()  то мы идем вперед в controler.
    } catch (e) {
      next(e);
      //В данном блоке catch мы получаем ошибку и данную ошибку передаем в метод next(e); далее мы возвращаемся на один уровеь назад в app.ts где
      //она будет обработана в hemdlere для ошибок. И там же будет отправлен ответ на фронт с ошибкой.
      //next(erorr) ->   с ошибкой можно вызывать в любом месте .
    }
  }
}

export const userMiddleware = new UserMiddleware();
